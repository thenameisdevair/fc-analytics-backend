"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Neynar API
 * The Neynar API allows you to interact with the Farcaster protocol among other things. See the [Neynar docs](https://docs.neynar.com/reference) for more details.
 *
 * The version of the OpenAPI document: 3.100.0
 * Contact: team@neynar.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchFramesNetworksEnum = exports.FetchRelevantFramesNetworksEnum = exports.FetchRelevantFramesTimeWindowEnum = exports.FetchFrameCatalogNetworksEnum = exports.FetchFrameCatalogCategoriesEnum = exports.FetchFrameCatalogTimeWindowEnum = exports.FrameApi = exports.FrameApiFactory = exports.FrameApiFp = exports.FrameApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * FrameApi - axios parameter creator
 * @export
 */
const FrameApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {number} [limit] Number of results to fetch  (Default: 100, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {FetchFrameCatalogTimeWindowEnum} [timeWindow] Time window used to calculate the change in trending score for each mini app, used to sort mini app results
         * @param {Array<FetchFrameCatalogCategoriesEnum>} [categories] Comma separated list of categories to include in the results. Includes all if left blank. Example: categories&#x3D;games,social OR categories&#x3D;games&amp;categories&#x3D;social
         * @param {Array<FetchFrameCatalogNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         *
         */
        fetchFrameCatalog: async (limit, cursor, timeWindow, categories, networks, options = {}) => {
            const localVarPath = `/v2/farcaster/frame/catalog/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (timeWindow !== undefined) {
                localVarQueryParameter['time_window'] = timeWindow;
            }
            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }
            if (networks) {
                localVarQueryParameter['networks'] = networks;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [fids] Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app.
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         *
         */
        fetchNotificationTokens: async (limit, fids, cursor, options = {}) => {
            const localVarPath = `/v2/farcaster/frame/notification_tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fids !== undefined) {
                localVarQueryParameter['fids'] = fids;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {number} viewerFid FID of the user to fetch relevant mini apps for
         * @param {FetchRelevantFramesTimeWindowEnum} [timeWindow] Time window used to limit statistics used to calculate mini app relevance
         * @param {Array<FetchRelevantFramesNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         *
         */
        fetchRelevantFrames: async (viewerFid, timeWindow, networks, options = {}) => {
            // verify required parameter 'viewerFid' is not null or undefined
            (0, common_1.assertParamExists)('fetchRelevantFrames', 'viewerFid', viewerFid);
            const localVarPath = `/v2/farcaster/frame/relevant/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }
            if (timeWindow !== undefined) {
                localVarQueryParameter['time_window'] = timeWindow;
            }
            if (networks) {
                localVarQueryParameter['networks'] = networks;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {string} [campaignId] An ID of a specific notification campaign to query
         * @param {number} [limit] The number of results to return  (Default: 100, Maximum: 1000)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         *
         */
        getNotificationCampaignStats: async (campaignId, limit, cursor, options = {}) => {
            const localVarPath = `/v2/farcaster/frame/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (campaignId !== undefined) {
                localVarQueryParameter['campaign_id'] = campaignId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {string} id ID of the transaction mini app to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         *
         */
        getTransactionPayFrame: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionPayFrame', 'id', id);
            const localVarPath = `/v2/farcaster/frame/transaction/pay/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {SendFrameNotificationsReqBody} sendFrameNotificationsReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         *
         */
        publishFrameNotifications: async (sendFrameNotificationsReqBody, options = {}) => {
            // verify required parameter 'sendFrameNotificationsReqBody' is not null or undefined
            (0, common_1.assertParamExists)('publishFrameNotifications', 'sendFrameNotificationsReqBody', sendFrameNotificationsReqBody);
            const localVarPath = `/v2/farcaster/frame/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sendFrameNotificationsReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {string} q Query string to search for mini apps
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {Array<SearchFramesNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         *
         */
        searchFrames: async (q, limit, cursor, networks, options = {}) => {
            // verify required parameter 'q' is not null or undefined
            (0, common_1.assertParamExists)('searchFrames', 'q', q);
            const localVarPath = `/v2/farcaster/frame/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (networks) {
                localVarQueryParameter['networks'] = networks;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FrameApiAxiosParamCreator = FrameApiAxiosParamCreator;
/**
 * FrameApi - functional programming interface
 * @export
 */
const FrameApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FrameApiAxiosParamCreator)(configuration);
    return {
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {number} [limit] Number of results to fetch  (Default: 100, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {FetchFrameCatalogTimeWindowEnum} [timeWindow] Time window used to calculate the change in trending score for each mini app, used to sort mini app results
         * @param {Array<FetchFrameCatalogCategoriesEnum>} [categories] Comma separated list of categories to include in the results. Includes all if left blank. Example: categories&#x3D;games,social OR categories&#x3D;games&amp;categories&#x3D;social
         * @param {Array<FetchFrameCatalogNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         *
         */
        async fetchFrameCatalog(limit, cursor, timeWindow, categories, networks, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFrameCatalog(limit, cursor, timeWindow, categories, networks, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchFrameCatalog']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [fids] Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app.
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         *
         */
        async fetchNotificationTokens(limit, fids, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchNotificationTokens(limit, fids, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchNotificationTokens']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {number} viewerFid FID of the user to fetch relevant mini apps for
         * @param {FetchRelevantFramesTimeWindowEnum} [timeWindow] Time window used to limit statistics used to calculate mini app relevance
         * @param {Array<FetchRelevantFramesNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         *
         */
        async fetchRelevantFrames(viewerFid, timeWindow, networks, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRelevantFrames(viewerFid, timeWindow, networks, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchRelevantFrames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {string} [campaignId] An ID of a specific notification campaign to query
         * @param {number} [limit] The number of results to return  (Default: 100, Maximum: 1000)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         *
         */
        async getNotificationCampaignStats(campaignId, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationCampaignStats(campaignId, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.getNotificationCampaignStats']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {string} id ID of the transaction mini app to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         *
         */
        async getTransactionPayFrame(id, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionPayFrame(id, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.getTransactionPayFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {SendFrameNotificationsReqBody} sendFrameNotificationsReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         *
         */
        async publishFrameNotifications(sendFrameNotificationsReqBody, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishFrameNotifications(sendFrameNotificationsReqBody, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.publishFrameNotifications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {string} q Query string to search for mini apps
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {Array<SearchFramesNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         *
         */
        async searchFrames(q, limit, cursor, networks, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFrames(q, limit, cursor, networks, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.searchFrames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.FrameApiFp = FrameApiFp;
/**
 * FrameApi - factory interface
 * @export
 */
const FrameApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FrameApiFp)(configuration);
    return {
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         *
         */
        fetchFrameCatalog(requestParameters = {}, options) {
            return localVarFp.fetchFrameCatalog(requestParameters.limit, requestParameters.cursor, requestParameters.timeWindow, requestParameters.categories, requestParameters.networks, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         *
         */
        fetchNotificationTokens(requestParameters = {}, options) {
            return localVarFp.fetchNotificationTokens(requestParameters.limit, requestParameters.fids, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         *
         */
        fetchRelevantFrames(requestParameters, options) {
            return localVarFp.fetchRelevantFrames(requestParameters.viewerFid, requestParameters.timeWindow, requestParameters.networks, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         *
         */
        getNotificationCampaignStats(requestParameters = {}, options) {
            return localVarFp.getNotificationCampaignStats(requestParameters.campaignId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         *
         */
        getTransactionPayFrame(requestParameters, options) {
            return localVarFp.getTransactionPayFrame(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         *
         */
        publishFrameNotifications(requestParameters, options) {
            return localVarFp.publishFrameNotifications(requestParameters.sendFrameNotificationsReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         *
         */
        searchFrames(requestParameters, options) {
            return localVarFp.searchFrames(requestParameters.q, requestParameters.limit, requestParameters.cursor, requestParameters.networks, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FrameApiFactory = FrameApiFactory;
/**
 * FrameApi - object-oriented interface
 * @export
 * @class FrameApi
 * @extends {BaseAPI}
 */
class FrameApi extends base_1.BaseAPI {
    /**
     * A curated list of featured mini apps
     * @summary Mini apps catalog
     * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
     *
     */
    fetchFrameCatalog(requestParameters = {}, options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchFrameCatalog(requestParameters.limit, requestParameters.cursor, requestParameters.timeWindow, requestParameters.categories, requestParameters.networks, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of notifications tokens related to a mini app
     * @summary List of mini app notification tokens
     * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
     *
     */
    fetchNotificationTokens(requestParameters = {}, options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchNotificationTokens(requestParameters.limit, requestParameters.fids, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
     * @summary Relevant mini apps
     * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
     *
     */
    fetchRelevantFrames(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchRelevantFrames(requestParameters.viewerFid, requestParameters.timeWindow, requestParameters.networks, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve notification delivery and opened stats for notification campaigns
     * @summary Get notification campaign stats
     * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
     *
     */
    getNotificationCampaignStats(requestParameters = {}, options) {
        return (0, exports.FrameApiFp)(this.configuration).getNotificationCampaignStats(requestParameters.campaignId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves details about a transaction pay mini app by ID
     * @summary Get transaction pay mini app
     * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
     *
     */
    getTransactionPayFrame(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).getTransactionPayFrame(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send notifications to interactors of a mini app
     * @summary Send notifications
     * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
     *
     */
    publishFrameNotifications(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).publishFrameNotifications(requestParameters.sendFrameNotificationsReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search for mini apps based on a query string
     * @summary Search mini apps
     * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
     *
     */
    searchFrames(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).searchFrames(requestParameters.q, requestParameters.limit, requestParameters.cursor, requestParameters.networks, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FrameApi = FrameApi;
/**
 * @export
 */
exports.FetchFrameCatalogTimeWindowEnum = {
    _1h: '1h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h',
    _7d: '7d'
};
/**
 * @export
 */
exports.FetchFrameCatalogCategoriesEnum = {
    Games: 'games',
    Social: 'social',
    Finance: 'finance',
    Utility: 'utility',
    Productivity: 'productivity',
    HealthFitness: 'health-fitness',
    NewsMedia: 'news-media',
    Music: 'music',
    Shopping: 'shopping',
    Education: 'education',
    DeveloperTools: 'developer-tools',
    Entertainment: 'entertainment',
    ArtCreativity: 'art-creativity'
};
/**
 * @export
 */
exports.FetchFrameCatalogNetworksEnum = {
    Ethereum: 'ethereum',
    Base: 'base',
    Arbitrum: 'arbitrum',
    ArbitrumSepolia: 'arbitrum-sepolia',
    BaseSepolia: 'base-sepolia',
    Degen: 'degen',
    Gnosis: 'gnosis',
    Optimism: 'optimism',
    OptimismSepolia: 'optimism-sepolia',
    Polygon: 'polygon',
    EthereumSepolia: 'ethereum-sepolia',
    Zora: 'zora',
    Unichain: 'unichain',
    MonadTestnet: 'monad-testnet',
    Celo: 'celo',
    Solana: 'solana'
};
/**
 * @export
 */
exports.FetchRelevantFramesTimeWindowEnum = {
    _1h: '1h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h',
    _7d: '7d'
};
/**
 * @export
 */
exports.FetchRelevantFramesNetworksEnum = {
    Ethereum: 'ethereum',
    Base: 'base',
    Arbitrum: 'arbitrum',
    ArbitrumSepolia: 'arbitrum-sepolia',
    BaseSepolia: 'base-sepolia',
    Degen: 'degen',
    Gnosis: 'gnosis',
    Optimism: 'optimism',
    OptimismSepolia: 'optimism-sepolia',
    Polygon: 'polygon',
    EthereumSepolia: 'ethereum-sepolia',
    Zora: 'zora',
    Unichain: 'unichain',
    MonadTestnet: 'monad-testnet',
    Celo: 'celo',
    Solana: 'solana'
};
/**
 * @export
 */
exports.SearchFramesNetworksEnum = {
    Ethereum: 'ethereum',
    Base: 'base',
    Arbitrum: 'arbitrum',
    ArbitrumSepolia: 'arbitrum-sepolia',
    BaseSepolia: 'base-sepolia',
    Degen: 'degen',
    Gnosis: 'gnosis',
    Optimism: 'optimism',
    OptimismSepolia: 'optimism-sepolia',
    Polygon: 'polygon',
    EthereumSepolia: 'ethereum-sepolia',
    Zora: 'zora',
    Unichain: 'unichain',
    MonadTestnet: 'monad-testnet',
    Celo: 'celo',
    Solana: 'solana'
};
